import html2canvas from 'html2canvas';
import { ReadingResponse } from '../services/api'; // Assuming ReadingResponse is defined here
import { COLORS, TYPOGRAPHY } from '../styles/theme'; // Import theme for styling

/**
 * Generates a shareable PNG image from the reading data.
 * 
 * @param readingData - The data object containing the daily reading information.
 * @param elementToCapture - The DOM element containing the content to capture (optional).
 * @returns A Promise that resolves with the generated image data URL (PNG format).
 */
export const generateShareImage = async (
  readingData: ReadingResponse,
  elementToCapture?: HTMLElement | null
): Promise<string> => {
  console.log('Generating share image...');

  // If an element is provided, capture it directly
  if (elementToCapture) {
    try {
      console.log('Capturing provided element...');
      const canvas = await html2canvas(elementToCapture, {
        backgroundColor: COLORS.BLACK, // Set background color
        useCORS: true, // Enable cross-origin images if needed
        scale: 2, // Increase scale for better resolution
      });
      const dataUrl = canvas.toDataURL('image/png');
      console.log('Element capture successful.');
      return dataUrl;
    } catch (error) {
      console.error('Error capturing element:', error);
      // Fallback to drawing manually if element capture fails
    }
  }

  // Manual drawing fallback using Canvas API
  console.log('Drawing image manually using Canvas API...');
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const width = 500; // Target width for the image
  const height = 500; // Target height for the image
  const padding = 30;

  canvas.width = width;
  canvas.height = height;

  if (!ctx) {
    throw new Error('Could not get canvas context');
  }

  // 1. Draw Background
  ctx.fillStyle = COLORS.BLACK;
  ctx.fillRect(0, 0, width, height);

  // 2. Draw Border (optional neon effect)
  ctx.strokeStyle = COLORS.NEON_GREEN;
  ctx.lineWidth = 4;
  ctx.strokeRect(2, 2, width - 4, height - 4);
  // Add a subtle glow (optional)
  ctx.shadowColor = COLORS.NEON_GREEN;
  ctx.shadowBlur = 10;
  ctx.strokeRect(2, 2, width - 4, height - 4);
  ctx.shadowColor = 'transparent'; // Reset shadow
  ctx.shadowBlur = 0;

  // 3. Draw Title
  ctx.fillStyle = COLORS.NEON_PURPLE;
  ctx.font = `bold ${TYPOGRAPHY.HEADLINE.fontSize || '24px'} sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText('AstroApp Daily Reading', width / 2, padding + 30);

  // 4. Draw Zodiac Info
  ctx.fillStyle = COLORS.NEON_GREEN;
  ctx.font = `bold ${TYPOGRAPHY.SUBHEADLINE.fontSize || '18px'} sans-serif`;
  ctx.fillText(`Your Zodiac: ${readingData.zodiac}`, width / 2, padding + 80);

  // 5. Draw Reading Text (with wrapping)
  ctx.fillStyle = COLORS.WHITE;
  ctx.font = `${TYPOGRAPHY.BODY.fontSize || '14px'} sans-serif`;
  const maxTextWidth = width - padding * 2;
  let yPos = padding + 120;
  const lines = wrapText(ctx, readingData.reading, maxTextWidth);
  lines.forEach((line, index) => {
    ctx.fillText(line, width / 2, yPos + index * 20);
  });
  yPos += lines.length * 20 + 10; // Adjust yPos after drawing text

  // 6. Draw Elemental Balance (Simplified for canvas)
  ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
  ctx.fillRect(padding, yPos, width - padding * 2, 20); // Background bar
  
  // Draw dominant element segment
  const elementColor = getElementColorCanvas(readingData.dominantElement);
  ctx.fillStyle = elementColor;
  const barWidth = (width - padding * 2) * (readingData.elementPercent / 100);
  ctx.fillRect(padding, yPos, barWidth, 20);

  ctx.fillStyle = COLORS.WHITE;
  ctx.font = `${TYPOGRAPHY.CAPTION.fontSize || '12px'} sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText(
    `Dominant Element: ${readingData.dominantElement} (${readingData.elementPercent}%)`,
    width / 2,
    yPos + 40
  );

  // 7. Add Watermark/Footer (optional)
  ctx.fillStyle = COLORS.GRAY;
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText('Generated by AstroApp', width - padding, height - padding + 10);

  console.log('Manual drawing complete.');
  return canvas.toDataURL('image/png');
};

/**
 * Helper function to wrap text for canvas drawing.
 * @param context Canvas rendering context.
 * @param text The text to wrap.
 * @param maxWidth The maximum width for a line.
 * @returns An array of strings, each representing a line.
 */
const wrapText = (
  context: CanvasRenderingContext2D,
  text: string,
  maxWidth: number
): string[] => {
  const words = text.split(' ');
  const lines: string[] = [];
  let currentLine = words[0];

  for (let i = 1; i < words.length; i++) {
    const word = words[i];
    const width = context.measureText(currentLine + ' ' + word).width;
    if (width < maxWidth) {
      currentLine += ' ' + word;
    } else {
      lines.push(currentLine);
      currentLine = word;
    }
  }
  lines.push(currentLine);
  return lines;
};

/**
 * Helper function to get element color for Canvas API.
 * (Duplicates logic from DailyReading component for canvas use).
 */
const getElementColorCanvas = (element: string): string => {
  switch (element?.toLowerCase()) {
    case 'wood': return '#4CAF50';
    case 'fire': return '#FF5722';
    case 'earth': return '#8D6E63';
    case 'metal': return '#9E9E9E';
    case 'water': return '#2196F3';
    default: return COLORS.GRAY || '#CCCCCC';
  }
}; 